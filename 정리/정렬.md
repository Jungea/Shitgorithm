# 정렬

## 버블정렬
- 인접한 두 값을 비교해서 더 큰 값을 오른쪽으로 밀어낸다.
- 최악/평균 : O(n²)
- 최선 (이미 정렬된 경우 + 개선형) : O(n)

### 예시 ([5, 3, 8, 4, 2])

1회차:
[5, 3] → 스왑, [5, 8] → X, [8, 4] → 스왑, [8, 2] → 스왑
→ 결과: [3, 5, 4, 2, 8] → 8 확정

2회차:
[3, 5] → X, [5, 4] → 스왑, [5, 2] → 스왑
→ 결과: [3, 4, 2, 5, 8] → 5 확정

### 구현
```java
public static void bubbleSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        boolean swapped = false;  // 최선의 케이스 개선형
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr, j, j + 1);
                swapped = true;
            }
        }
        if (!swapped) break;
    }
}
```

## 선택정렬
- 가장 작은 값을 선택해서 앞에 보낸다
- 최악/평균/최선 : O(n²)
- 불안정 정렬 : 동일한 값인 경우 순서를 보장하지 않는다.

### 예시 [5, 3, 8, 4, 2]
1. i = 0 → [**2**, 3, 8, 4, **5**] → `swap(0, 4)` → `[2, 3, 8, 4, 5]`
2. i = 1 → [2, **3**, 8, 4, 5] → `min = 3` → 그대로
3. i = 2 → [2, 3, **8**, **4**, 5] → `swap(2, 3)` → `[2, 3, 4, 8, 5]`
4. i = 3 → [2, 3, 4, **8**, **5**] → `swap(3, 4)` → `[2, 3, 4, 5, 8]`

### 구현
```java
public static void selectionSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int minIdx = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        swap(arr, i, minIdx);
    }
}
```